import { createRequire } from 'module'; const require = createRequire(import.meta.url);
import{a as $,b as w,c as A,e as y,q as xt,r as B}from"./chunk-4BT7DEQT.js";var W=A(u=>{"use strict";var{promisify:bt}=$("util"),H=$("fs");async function T(t,e,r){if(typeof r!="string")throw new TypeError(`Expected a string, got ${typeof r}`);try{return(await bt(H[t])(r))[e]()}catch(n){if(n.code==="ENOENT")return!1;throw n}}function R(t,e,r){if(typeof r!="string")throw new TypeError(`Expected a string, got ${typeof r}`);try{return H[t](r)[e]()}catch(n){if(n.code==="ENOENT")return!1;throw n}}u.isFile=T.bind(null,"stat","isFile");u.isDirectory=T.bind(null,"stat","isDirectory");u.isSymlink=T.bind(null,"lstat","isSymbolicLink");u.isFileSync=R.bind(null,"statSync","isFile");u.isDirectorySync=R.bind(null,"statSync","isDirectory");u.isSymlinkSync=R.bind(null,"lstatSync","isSymbolicLink")});var U=A((re,I)=>{"use strict";var d=$("path"),q=W(),M=t=>t.length>1?`{${t.join(",")}}`:t[0],K=(t,e)=>{let r=t[0]==="!"?t.slice(1):t;return d.isAbsolute(r)?r:d.join(e,r)},St=(t,e)=>d.extname(t)?`**/${t}`:`**/${t}.${M(e)}`,V=(t,e)=>{if(e.files&&!Array.isArray(e.files))throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof e.files}\``);if(e.extensions&&!Array.isArray(e.extensions))throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof e.extensions}\``);return e.files&&e.extensions?e.files.map(r=>d.posix.join(t,St(r,e.extensions))):e.files?e.files.map(r=>d.posix.join(t,`**/${r}`)):e.extensions?[d.posix.join(t,`**/*.${M(e.extensions)}`)]:[d.posix.join(t,"**")]};I.exports=async(t,e)=>{if(e={cwd:process.cwd(),...e},typeof e.cwd!="string")throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof e.cwd}\``);let r=await Promise.all([].concat(t).map(async n=>await q.isDirectory(K(n,e.cwd))?V(n,e):n));return[].concat.apply([],r)};I.exports.sync=(t,e)=>{if(e={cwd:process.cwd(),...e},typeof e.cwd!="string")throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof e.cwd}\``);let r=[].concat(t).map(n=>q.isDirectorySync(K(n,e.cwd))?V(n,e):n);return[].concat.apply([],r)}});var st=A((ne,nt)=>{function Y(t){return Array.isArray(t)?t:[t]}var tt="",J=" ",G="\\",Pt=/^\s+$/,$t=/^\\!/,At=/^\\#/,Tt=/\r?\n/g,Rt=/^\.*\/|^\.+$/,v="/",Q=typeof Symbol<"u"?Symbol.for("node-ignore"):"node-ignore",It=(t,e,r)=>Object.defineProperty(t,e,{value:r}),Gt=/([0-z])-([0-z])/g,et=()=>!1,vt=t=>t.replace(Gt,(e,r,n)=>r.charCodeAt(0)<=n.charCodeAt(0)?e:tt),Ft=t=>{let{length:e}=t;return t.slice(0,e-e%2)},Nt=[[/\\?\s+$/,t=>t.indexOf("\\")===0?J:tt],[/\\\s/g,()=>J],[/[\\$.|*+(){^]/g,t=>`\\${t}`],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(t,e,r)=>e+6<r.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)\\\*(?=.+)/g,(t,e)=>`${e}[^\\/]*`],[/\\\\\\(?=[$.|*+(){^])/g,()=>G],[/\\\\/g,()=>G],[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,(t,e,r,n,s)=>e===G?`\\[${r}${Ft(n)}${s}`:s==="]"&&n.length%2===0?`[${vt(r)}${n}]`:"[]"],[/(?:[^*])$/,t=>/\/$/.test(t)?`${t}$`:`${t}(?=$|\\/$)`],[/(\^|\\\/)?\\\*$/,(t,e)=>`${e?`${e}[^/]+`:"[^/]*"}(?=$|\\/$)`]],Z=Object.create(null),Lt=(t,e)=>{let r=Z[t];return r||(r=Nt.reduce((n,s)=>n.replace(s[0],s[1].bind(t)),t),Z[t]=r),e?new RegExp(r,"i"):new RegExp(r)},L=t=>typeof t=="string",Ct=t=>t&&L(t)&&!Pt.test(t)&&t.indexOf("#")!==0,Ot=t=>t.split(Tt),F=class{constructor(e,r,n,s){this.origin=e,this.pattern=r,this.negative=n,this.regex=s}},kt=(t,e)=>{let r=t,n=!1;t.indexOf("!")===0&&(n=!0,t=t.substr(1)),t=t.replace($t,"!").replace(At,"#");let s=Lt(t,e);return new F(r,t,n,s)},Dt=(t,e)=>{throw new e(t)},i=(t,e,r)=>L(t)?t?i.isNotRelative(t)?r(`path should be a \`path.relative()\`d string, but got "${e}"`,RangeError):!0:r("path must not be empty",TypeError):r(`path must be a string, but got \`${e}\``,TypeError),rt=t=>Rt.test(t);i.isNotRelative=rt;i.convert=t=>t;var N=class{constructor({ignorecase:e=!0,ignoreCase:r=e,allowRelativePaths:n=!1}={}){It(this,Q,!0),this._rules=[],this._ignoreCase=r,this._allowRelativePaths=n,this._initCache()}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}_addPattern(e){if(e&&e[Q]){this._rules=this._rules.concat(e._rules),this._added=!0;return}if(Ct(e)){let r=kt(e,this._ignoreCase);this._added=!0,this._rules.push(r)}}add(e){return this._added=!1,Y(L(e)?Ot(e):e).forEach(this._addPattern,this),this._added&&this._initCache(),this}addPattern(e){return this.add(e)}_testOne(e,r){let n=!1,s=!1;return this._rules.forEach(o=>{let{negative:c}=o;if(s===c&&n!==s||c&&!n&&!s&&!r)return;o.regex.test(e)&&(n=!c,s=c)}),{ignored:n,unignored:s}}_test(e,r,n,s){let o=e&&i.convert(e);return i(o,e,this._allowRelativePaths?et:Dt),this._t(o,r,n,s)}_t(e,r,n,s){if(e in r)return r[e];if(s||(s=e.split(v)),s.pop(),!s.length)return r[e]=this._testOne(e,n);let o=this._t(s.join(v)+v,r,n,s);return r[e]=o.ignored?o:this._testOne(e,n)}ignores(e){return this._test(e,this._ignoreCache,!1).ignored}createFilter(){return e=>!this.ignores(e)}filter(e){return Y(e).filter(this.createFilter())}test(e){return this._test(e,this._testCache,!0)}},_=t=>new N(t),jt=t=>i(t&&i.convert(t),t,et);_.isPathValid=jt;_.default=_;nt.exports=_;if(typeof process<"u"&&(process.env&&process.env.IGNORE_TEST_WIN32||process.platform==="win32")){let t=r=>/^\\\\\?\\/.test(r)||/["<>|\u0000-\u001F]+/u.test(r)?r:r.replace(/\\/g,"/");i.convert=t;let e=/^[a-z]:\//i;i.isNotRelative=r=>e.test(r)||rt(r)}});function g(t){let e=/^\\\\\?\\/.test(t),r=/[^\u0000-\u0080]+/.test(t);return e||r?t:t.replace(/\\/g,"/")}var ot=w(()=>{});import{fileURLToPath as Xt}from"url";import{Transform as zt}from"stream";var p,x,b,C=w(()=>{p=t=>t instanceof URL?Xt(t):t,x=class extends zt{constructor(e){super({objectMode:!0,transform(r,n,s){s(void 0,e(r)?r:void 0)}})}},b=t=>t[0]==="!"});import Bt from"process";import it from"fs";import f from"path";var O,ct,at,S,Ht,Wt,qt,lt,ut,k,D,Mt,Kt,j=w(()=>{O=y(B(),1),ct=y(st(),1);ot();C();at={ignore:["**/node_modules","**/flow-typed","**/coverage","**/.git"],absolute:!0,dot:!0},S="**/.gitignore",Ht=(t,e)=>b(t)?"!"+f.posix.join(e,t.slice(1)):f.posix.join(e,t),Wt=(t,e)=>{let r=g(f.relative(e,f.dirname(t.filePath)));return t.content.split(/\r?\n/).filter(n=>n&&!n.startsWith("#")).map(n=>Ht(n,r))},qt=(t,e)=>{if(e=g(e),f.isAbsolute(t)){if(g(t).startsWith(e))return f.relative(e,t);throw new Error(`Path ${t} is not in cwd ${e}`)}return t},lt=(t,e)=>{let r=t.flatMap(s=>Wt(s,e)),n=(0,ct.default)().add(r);return s=>(s=p(s),s=qt(s,e),n.ignores(g(s)))},ut=(t={})=>({cwd:p(t.cwd)||Bt.cwd()}),k=async(t,e)=>{let{cwd:r}=ut(e),n=await(0,O.default)(t,{cwd:r,...at}),s=await Promise.all(n.map(async o=>({filePath:o,content:await it.promises.readFile(o,"utf8")})));return lt(s,r)},D=(t,e)=>{let{cwd:r}=ut(e),s=O.default.sync(t,{cwd:r,...at}).map(o=>({filePath:o,content:it.readFileSync(o,"utf8")}));return lt(s,r)},Mt=t=>k(S,t),Kt=t=>D(S,t)});import Vt from"fs";import Ut from"path";var dt,h,m,Yt,X,Jt,gt,ft,P,yt,Qt,pt,mt,ht,Zt,Et,wt,_t,z,Ee,we,_e,xe,be,Se,te=w(()=>{dt=y(xt(),1),h=y(B(),1),m=y(U(),1);j();C();j();Yt=t=>{if(t.some(e=>typeof e!="string"))throw new TypeError("Patterns must be a string or an array of strings")},X=t=>(t=[...new Set([t].flat())],Yt(t),t),Jt=t=>{if(!t.cwd)return;let e;try{e=Vt.statSync(t.cwd)}catch{return}if(!e.isDirectory())throw new Error("The `cwd` option must be a path to a directory")},gt=(t={})=>(t={ignore:[],expandDirectories:!0,...t,cwd:p(t.cwd)},Jt(t),t),ft=t=>async(e,r)=>t(X(e),gt(r)),P=t=>(e,r)=>t(X(e),gt(r)),yt=t=>{let{ignoreFiles:e,gitignore:r}=t,n=e?X(e):[];return r&&n.push(S),n},Qt=async t=>{let e=yt(t);return mt(e.length>0&&await k(e,{cwd:t.cwd}))},pt=t=>{let e=yt(t);return mt(e.length>0&&D(e,{cwd:t.cwd}))},mt=t=>{let e=new Set;return r=>{let n=r.path||r,s=Ut.normalize(n),o=e.has(s)||t&&t(n);return e.add(s),!o}},ht=(t,e)=>t.flat().filter(r=>e(r)),Zt=(t,e)=>(0,dt.default)(t).pipe(new x(r=>e(r))),Et=(t,e)=>{let r=[];for(;t.length>0;){let n=t.findIndex(o=>b(o));if(n===-1){r.push({patterns:t,options:e});break}let s=t[n].slice(1);for(let o of r)o.options.ignore.push(s);n!==0&&r.push({patterns:t.slice(0,n),options:{...e,ignore:[...e.ignore,s]}}),t=t.slice(n+1)}return r},wt=(t,e)=>({...e?{cwd:e}:{},...Array.isArray(t)?{files:t}:t}),_t=async(t,e)=>{let r=Et(t,e),{cwd:n,expandDirectories:s}=e;if(!s)return r;let o=wt(s,n),c=n?{cwd:n}:void 0;return Promise.all(r.map(async E=>{let{patterns:a,options:l}=E;return[a,l.ignore]=await Promise.all([(0,m.default)(a,o),(0,m.default)(l.ignore,c)]),{patterns:a,options:l}}))},z=(t,e)=>{let r=Et(t,e),{cwd:n,expandDirectories:s}=e;if(!s)return r;let o=wt(s,n),c=n?{cwd:n}:void 0;return r.map(E=>{let{patterns:a,options:l}=E;return a=m.default.sync(a,o),l.ignore=m.default.sync(l.ignore,c),{patterns:a,options:l}})},Ee=ft(async(t,e)=>{let[r,n]=await Promise.all([_t(t,e),Qt(e)]),s=await Promise.all(r.map(o=>(0,h.default)(o.patterns,o.options)));return ht(s,n)}),we=P((t,e)=>{let r=z(t,e),n=pt(e),s=r.map(o=>h.default.sync(o.patterns,o.options));return ht(s,n)}),_e=P((t,e)=>{let r=z(t,e),n=pt(e),s=r.map(o=>h.default.stream(o.patterns,o.options));return Zt(s,n)}),xe=P((t,e)=>t.some(r=>h.default.isDynamicPattern(r,e))),be=ft(_t),Se=P(z)});te();export{be as generateGlobTasks,Se as generateGlobTasksSync,Ee as globby,_e as globbyStream,we as globbySync,xe as isDynamicPattern,Mt as isGitIgnored,Kt as isGitIgnoredSync};
//# sourceMappingURL=globby-UHR4XBVL.js.map